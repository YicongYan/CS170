Name: Yicong Yan
PERM #: 8087736

Collaborators (who you talked to about the lab, what you talked about):


Source material that you consulted: textbook


Other acknowledgments: 


-------------------------------------------------------------------------------

Responses to exercises (if any) that need to go into answers.txt:

Exercise 5:

No, if run(current) is replaced by schedule() in INT_SYS_GETPID, sys_getpid() is not guaranteed to return the correct value. The reason is that run(current) is to reload 
all the relevant registers of the process that is pointed to by the pointer "current", so the pid of the current process would be in %eax. 
However, schedule() picks a runnable process, then reloads all the relevant registers of that process, it's not guaranteed that schedule() picks the correct process, it might
pick a process that we don't call sys_getpid() on and reload the registers using its information, so it's very likely that schedule() will load the wrong value into %eax.

Exercise 7:

So in the process descriptor in kernel.h,  I add a p_waiting[16] as a waiting queue, and in start() I initialize it to be -1 for every element. Then in INT_SYS_WAIT,
when a process is called but has not yet exited. Then, it should set the current process to be P_BLOCKED, and then put current process;s pid into the waiting queue
of the process it wants to wait for. Then in INT_SYS_EXIT, before schdule(), the current process will check whether there is any process it needs to wake before
it exits using a for loop, if there is one, return the current process exit status to the blocked process's eax and set it back to P_RUNNABLE.

Exercise 10:
The base version outputs:
A
2
C

Exercise 11:

This is the information of my commit:
Merge: c58353a a801181
Author: YicongYan <yicongyan@ucsb.edu>


Anything else you'd like us to know:
If you didn't see the file you want, please check my gihub: https://github.com/YicongYan/CS170    
I've put everything of this lab on it.
