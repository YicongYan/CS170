Name:
PERM #:

Collaborators (who you talked to about the lab, what you talked about):


Source material that you consulted:


Other acknowledgments:

-------------------------------------------------------------------------------

Part 1:

Exercise 1:

1.1: 
Informally, it means to search for the string "smutex" in the current directory and return the lines that contain it.

1.2:
sthread.cpp:void smutex_init(smutex_t *mutex)
sthread.cpp:void smutex_destroy(smutex_t *mutex)
sthread.cpp:void smutex_lock(smutex_t *mutex)

Exercise 2:

2.1:
grep "Task" RequestGenerator.cpp

2.2:
grep -r "return" *.h


Exercise 3:

grep -r "smutex.*(.*);" .

Let's first break down the string.

"." means any character (except for a newline character) zero or more times.

"(.*)" means any character (except for a newline character) zero or more times in parentheses.

so "smutex.*(.*);" means "smutex" followed by any character then followed by any characters in parentheses, so it's describing the 
function headers of smutex. 

So the command would return the function headers of smutex within all my files.

Exercise 4:

It opens blkdev.h.

Exercise 5: 

 futex_pi_state is priority inheritance state, it's is used to maintain information about the priority inheritance state of a futex.

It's defined in kernel/futex.c  line 188

Exercise 6: 

3 functions contain proc_sched and task, they are:

proc_sched_autogroup_show_task  in kernel/sched/auto_group.c

proc_sched_set_task             kernel/sched/debug.c

proc_sched_show_task            kernel/sched/debug.c


Exercise 7: 

3915

Part 2:
(Exercise 8 is a coding exercise)


Exercise 9:
Code after changed in linked_list.c:

int list_size(const list_t *h) {
    node_t *p = *h;
    int r = 0;
    while (p){
        r += 1;
        p = p->next; 
    }
    return r;
}

It was  a do while loop, when the list is empty, we search for the next element which does not exist,
and that gives us an error when we use "p = p->next; "

Exercise 10:

skip

Exercise 11:

skip

Exercise 12:

skip

(Exercise 13 is a coding exercise)

skip

Part 3:

Exercise 14:

The name of the scheduling algorithm is:
Round robin scheduling since it execute the process one by one.

(Exercise 15 is a coding exercise)


Exercise 16:

Average turnaround time for scheduling_algorithm 0:

320 Characters per process, 4 processes. Each process goes one at a time, waiting until the previous finished,
 so average time is simply 320 x 4 = 1280 ms.

Average turnaround time for scheduling_algorithm 1:

P1 runs without delay, so we expect it to take 320 ms.
P2 runs after P1, so we expect it to take 640 ms.
P3 runs after P1 and P2, so we expect it to take 960  ms.
P4 runs after P1, P2, and P3, so we expect it to take 1280  ms.
The sum is 3200 ms, so the average turnaround time is 3200 / 4 = 800 ms.


Average response time for scheduling_algorithm 0:

P1 has no delay, 0ms response time.
P2 runs  after P1, 1ms response time.
P3 runs  after P2, 2ms response time.
P4 runs  after P3, 3ms response time.
The sum is 6ms, so the average response time is 6 / 4 = 1.5ms.

Average response time for scheduling_algorithm 1:

P1 has a delay of 0 ms.
P2 runs after all of P1 finishes, has a delay of 320 ms.
P3 runs after all of P2 finishes, has a delay of 640 ms.
P4 runs after all of P3 finishes, has a delay of 960 ms.
The sum is 1920 ms, so the average response time is 1920 / 4 = 480

Exercise 17:

Did you complete Exercise 17A, Exercise 17B, or both?


Exercise 18:


(Exercise 19 is a coding exercise)


Anything else you'd like us to know:


